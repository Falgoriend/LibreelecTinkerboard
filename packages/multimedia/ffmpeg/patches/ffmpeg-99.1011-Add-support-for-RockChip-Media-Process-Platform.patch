From 7ccb14a41898139a7e58da00277a3e37d6a22f7d Mon Sep 17 00:00:00 2001
From: LongChair <LongChair@hotmail.com>
Date: Sat, 25 Mar 2017 08:24:59 +0100
Subject: [PATCH] Add support for RockChip Media Process Platform This adds
 hardware decoding for h264 / HEVC / VP8 using MPP Rockchip API. Will return
 frames holding a av_drmprime struct that allows drm / dmabuf usage.

---
 configure                   |  13 +
 libavcodec/Makefile         |   4 +
 libavcodec/allcodecs.c      |   6 +
 libavcodec/drmprime.h       |  17 ++
 libavcodec/rkmppdec.c       | 596 ++++++++++++++++++++++++++++++++++++++++++++
 libavcodec/rkqueue.c        |  75 ++++++
 libavcodec/rkqueue.h        |  27 ++
 libavutil/hwcontext_rkmpp.c | 164 ++++++++++++
 libavutil/hwcontext_rkmpp.h |   4 +
 libavutil/pixdesc.c         |   4 +
 libavutil/pixfmt.h          |   5 +
 11 files changed, 915 insertions(+)
 create mode 100644 libavcodec/drmprime.h
 create mode 100644 libavcodec/rkmppdec.c
 create mode 100644 libavcodec/rkqueue.c
 create mode 100644 libavcodec/rkqueue.h
 create mode 100644 libavutil/hwcontext_rkmpp.c
 create mode 100644 libavutil/hwcontext_rkmpp.h

diff --git a/configure b/configure
index 5eb11e4421..36da09ae3f 100755
--- a/configure
+++ b/configure
@@ -306,6 +306,7 @@ External library support:
   --enable-libmfx          enable Intel MediaSDK (AKA Quick Sync Video) code via libmfx [no]
   --enable-libnpp          enable Nvidia Performance Primitives-based code [no]
   --enable-mmal            enable Broadcom Multi-Media Abstraction Layer (Raspberry Pi) via MMAL [no]
+  --enable-rkmpp           enable RockiChip Media Process Platform [no]
   --enable-nvenc           enable Nvidia video encoding code [no]
   --enable-omx             enable OpenMAX IL code [no]
   --enable-omx-rpi         enable OpenMAX IL code for Raspberry Pi [no]
@@ -1562,6 +1563,7 @@ HWACCEL_LIBRARY_LIST="
     libmfx
     libnpp
     mmal
+    rkmpp
     nvenc
     omx
     vaapi
@@ -2560,6 +2562,9 @@ h264_mediacodec_decoder_select="h264_mp4toannexb_bsf h264_parser"
 h264_mmal_decoder_deps="mmal"
 h264_mmal_decoder_select="mmal"
 h264_mmal_hwaccel_deps="mmal"
+h264_rkmpp_decoder_deps="rkmpp"
+h264_rkmpp_decoder_select="rkmpp"
+h264_rkmpp_hwaccel_deps="rkmpp"
 h264_omx_encoder_deps="omx"
 h264_qsv_hwaccel_deps="libmfx"
 h264_vaapi_hwaccel_deps="vaapi"
@@ -2649,6 +2654,9 @@ vc1_vdpau_hwaccel_deps="vdpau"
 vc1_vdpau_hwaccel_select="vc1_decoder"
 vp8_cuvid_hwaccel_deps="cuda cuvid CUVIDVP9PICPARAMS"
 vp9_cuvid_hwaccel_deps="cuda cuvid CUVIDVP9PICPARAMS"
+vp8_rkmpp_decoder_deps="rkmpp"
+vp8_rkmpp_decoder_select="rkmpp"
+vp8_rkmpp_hwaccel_deps="rkmpp"
 vp9_d3d11va_hwaccel_deps="d3d11va DXVA_PicParams_VP9"
 vp9_d3d11va_hwaccel_select="vp9_decoder"
 vp9_dxva2_hwaccel_deps="dxva2 DXVA_PicParams_VP9"
@@ -2686,6 +2694,9 @@ h264_vaapi_encoder_select="vaapi_encode golomb"
 hevc_cuvid_decoder_deps="cuda cuvid CUVIDHEVCPICPARAMS"
 hevc_cuvid_decoder_select="hevc_mp4toannexb_bsf hevc_cuvid_hwaccel"
 hevc_nvenc_encoder_deps="nvenc"
+hevc_rkmpp_decoder_deps="rkmpp"
+hevc_rkmpp_decoder_select="rkmpp"
+hevc_rkmpp_hwaccel_deps="rkmpp"
 hevc_qsv_decoder_deps="libmfx"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf hevc_parser qsvdec hevc_qsv_hwaccel"
 hevc_qsv_encoder_deps="libmfx"
@@ -5760,6 +5771,8 @@ enabled mmal              && { check_lib interface/mmal/mmal.h mmal_port_connect
                                die "ERROR: mmal not found"; }
 enabled mmal && check_func_headers interface/mmal/mmal.h "MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS"
 
+enabled rkmpp              && { check_lib rockchip/rk_mpi.h mpp_create "-lrockchip_mpp" || die "ERROR : RockChip MPP was not found."; }
+
 enabled netcdf            && require_pkg_config netcdf netcdf.h nc_inq_libvers
 enabled nvenc             && { check_header nvEncodeAPI.h || die "ERROR: nvEncodeAPI.h not found."; } &&
                              { check_cpp_condition nvEncodeAPI.h "NVENCAPI_MAJOR_VERSION >= 6" ||
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index bb28aea1e2..cacf1f9ce5 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -18,6 +18,7 @@ HEADERS = avcodec.h                                                     \
           videotoolbox.h                                                \
           vorbis_parser.h                                               \
           xvmc.h                                                        \
+          drmprime.h                                                    \
 
 OBJS = allcodecs.o                                                      \
        audioconvert.o                                                   \
@@ -315,6 +316,7 @@ OBJS-$(CONFIG_H264_DECODER)            += h264.o h264_cabac.o h264_cavlc.o \
 OBJS-$(CONFIG_H264_CUVID_DECODER)      += cuvid.o
 OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec_h264.o
 OBJS-$(CONFIG_H264_MMAL_DECODER)       += mmaldec.o
+OBJS-$(CONFIG_H264_RKMPP_DECODER)      += rkmppdec.o rkqueue.o
 OBJS-$(CONFIG_H264_NVENC_ENCODER)      += nvenc_h264.o
 OBJS-$(CONFIG_NVENC_ENCODER)           += nvenc_h264.o
 OBJS-$(CONFIG_NVENC_H264_ENCODER)      += nvenc_h264.o
@@ -330,6 +332,7 @@ OBJS-$(CONFIG_HEVC_DECODER)            += hevc.o hevc_mvs.o hevc_ps.o hevc_sei.o
                                           hevc_cabac.o hevc_refs.o hevcpred.o    \
                                           hevcdsp.o hevc_filter.o h2645_parse.o hevc_data.o
 OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuvid.o
+OBJS-$(CONFIG_HEVC_RKMPP_DECODER)      += rkmppdec.o
 OBJS-$(CONFIG_HEVC_NVENC_ENCODER)      += nvenc_hevc.o
 OBJS-$(CONFIG_NVENC_HEVC_ENCODER)      += nvenc_hevc.o
 OBJS-$(CONFIG_HEVC_QSV_DECODER)        += qsvdec_h2645.o
@@ -589,6 +592,7 @@ OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o \
 OBJS-$(CONFIG_VP7_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_CUVID_DECODER)       += cuvid.o
+OBJS-$(CONFIG_VP8_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9dsp.o vp56rac.o vp9dsp_8bpp.o \
                                           vp9dsp_10bpp.o vp9dsp_12bpp.o
 OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuvid.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 54efaad344..25dc43188f 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -73,6 +73,7 @@ void avcodec_register_all(void)
     REGISTER_HWACCEL(H264_D3D11VA,      h264_d3d11va);
     REGISTER_HWACCEL(H264_DXVA2,        h264_dxva2);
     REGISTER_HWACCEL(H264_MMAL,         h264_mmal);
+    REGISTER_HWACCEL(H264_RKMPP,        h264_rkmpp);
     REGISTER_HWACCEL(H264_QSV,          h264_qsv);
     REGISTER_HWACCEL(H264_VAAPI,        h264_vaapi);
     REGISTER_HWACCEL(H264_VDA,          h264_vda);
@@ -85,6 +86,7 @@ void avcodec_register_all(void)
     REGISTER_HWACCEL(HEVC_QSV,          hevc_qsv);
     REGISTER_HWACCEL(HEVC_VAAPI,        hevc_vaapi);
     REGISTER_HWACCEL(HEVC_VDPAU,        hevc_vdpau);
+    REGISTER_HWACCEL(HEVC_RKMPP,        hevc_rkmpp);
     REGISTER_HWACCEL(MPEG1_XVMC,        mpeg1_xvmc);
     REGISTER_HWACCEL(MPEG1_VDPAU,       mpeg1_vdpau);
     REGISTER_HWACCEL(MPEG1_VIDEOTOOLBOX, mpeg1_videotoolbox);
@@ -108,6 +110,7 @@ void avcodec_register_all(void)
     REGISTER_HWACCEL(VC1_MMAL,          vc1_mmal);
     REGISTER_HWACCEL(VC1_QSV,           vc1_qsv);
     REGISTER_HWACCEL(VP8_CUVID,         vp8_cuvid);
+    REGISTER_HWACCEL(VP8_RKMPP,         vp8_rkmpp);
     REGISTER_HWACCEL(VP9_CUVID,         vp9_cuvid);
     REGISTER_HWACCEL(VP9_D3D11VA,       vp9_d3d11va);
     REGISTER_HWACCEL(VP9_DXVA2,         vp9_dxva2);
@@ -196,6 +199,7 @@ void avcodec_register_all(void)
     REGISTER_DECODER(H264_CRYSTALHD,    h264_crystalhd);
     REGISTER_DECODER(H264_MEDIACODEC,   h264_mediacodec);
     REGISTER_DECODER(H264_MMAL,         h264_mmal);
+    REGISTER_DECODER(H264_RKMPP,        h264_rkmpp);
     REGISTER_DECODER(H264_QSV,          h264_qsv);
     REGISTER_DECODER(H264_VDA,          h264_vda);
 #if FF_API_VDPAU
@@ -204,6 +208,7 @@ void avcodec_register_all(void)
     REGISTER_ENCDEC (HAP,               hap);
     REGISTER_DECODER(HEVC,              hevc);
     REGISTER_DECODER(HEVC_QSV,          hevc_qsv);
+    REGISTER_DECODER(HEVC_RKMPP,        hevc_rkmpp);
     REGISTER_DECODER(HNM4_VIDEO,        hnm4_video);
     REGISTER_DECODER(HQ_HQA,            hq_hqa);
     REGISTER_DECODER(HQX,               hqx);
@@ -350,6 +355,7 @@ void avcodec_register_all(void)
     REGISTER_DECODER(VP6F,              vp6f);
     REGISTER_DECODER(VP7,               vp7);
     REGISTER_DECODER(VP8,               vp8);
+    REGISTER_DECODER(VP8_RKMPP,         vp8_rkmpp);
     REGISTER_DECODER(VP9,               vp9);
     REGISTER_DECODER(VQA,               vqa);
     REGISTER_DECODER(WEBP,              webp);
diff --git a/libavcodec/drmprime.h b/libavcodec/drmprime.h
new file mode 100644
index 0000000000..e98cf56e91
--- /dev/null
+++ b/libavcodec/drmprime.h
@@ -0,0 +1,17 @@
+#ifndef DRMPRIME_H
+#define DRMPRIME_H
+
+#include <stdint.h>
+
+#define FF_DRMPRIME_NUM_PLANES	4	// maximum number of planes
+
+typedef struct {
+
+    uint32_t strides[FF_DRMPRIME_NUM_PLANES];
+    uint32_t offsets[FF_DRMPRIME_NUM_PLANES];
+    uint32_t fd;
+    uint32_t format;
+
+} av_drmprime;
+
+#endif // DRMPRIME_H
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
new file mode 100644
index 0000000000..8cffaa4b57
--- /dev/null
+++ b/libavcodec/rkmppdec.c
@@ -0,0 +1,596 @@
+#include <libdrm/drm_fourcc.h>
+#include <rockchip/mpp_buffer.h>
+#include <pthread.h>
+#include <rockchip/rk_mpi.h>
+#include <unistd.h>
+#include <time.h>
+
+#include "avcodec.h"
+#include "internal.h"
+#include "drmprime.h"
+#include "rkqueue.h"
+#include "libavutil/log.h"
+#include "libavutil/common.h"
+#include "libavutil/buffer.h"
+#include "libavutil/frame.h"
+#include "libavutil/imgutils.h"
+
+
+typedef struct {
+
+    AVBufferRef *ref;
+
+    MppCtx ctx;
+    MppApi *mpi;
+    MppBufferGroup frame_group;
+
+    char first_packet;
+    char eos_reached;
+
+} RKMPPDecoder;
+
+typedef struct {
+    AVClass *av_class;
+
+    // bitstream filter in case we need some annexb compliant stream
+    AVBSFContext *bsf;
+
+    RKMPPDecoder *decoder;
+    FrameQueue framequeue;
+
+    char output_started;
+    int framecount;
+    int fill_decoder;
+
+} RKMPPDecodeContext;
+
+static pthread_mutex_t release_lock = PTHREAD_MUTEX_INITIALIZER;
+
+static void profile_log(AVCodecContext *avctx, const char *fmt, ...)
+{
+    struct timespec time;
+    static struct timespec lasttime,starttime;
+    static int firstcall = 1;
+    int msec, usec, deltams;
+    va_list ap;
+    char stamp[32];
+    char msg[512];
+
+    if (firstcall) {
+        clock_gettime(CLOCK_REALTIME, &starttime);
+        firstcall = 0;
+    }
+
+    clock_gettime(CLOCK_REALTIME, &time);
+
+    msec = time.tv_nsec / 1000000;
+    usec = (time.tv_nsec - msec * 1000000) / 1000;
+    deltams = ((time.tv_sec * 1000000000 + time.tv_nsec) - (lasttime.tv_sec * 1000000000 + lasttime.tv_nsec)) / 1000000;
+
+    sprintf(stamp, "%03d:%03d.%03d (+%03d ms): ", (int)(time.tv_sec -  starttime.tv_sec), msec, usec, deltams);
+
+    lasttime.tv_sec = time.tv_sec;
+    lasttime.tv_nsec = time.tv_nsec;
+
+    va_start(ap, fmt);
+    vsprintf(msg, fmt, ap);
+    va_end(ap);
+
+    av_log(avctx, AV_LOG_DEBUG, "%s%s\n", stamp, msg);
+}
+
+static double ffrkmpp_compute_framerate(AVCodecContext *avctx)
+{
+    static struct timespec reftime;
+    static int refframecount;
+    struct timespec time;
+    double timediff;
+
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+
+    clock_gettime(CLOCK_REALTIME, &time);
+
+    if (rk_context->framecount == 1) {
+        refframecount = rk_context->framecount;
+        reftime.tv_sec  = time.tv_sec;
+        reftime.tv_nsec = time.tv_nsec;
+    }
+    timediff = ((double)time.tv_sec + ((double)time.tv_nsec / 1000000000.0)) -
+               ((double)reftime.tv_sec + ((double)reftime.tv_nsec / 1000000000.0));
+
+    if (timediff != 0)
+        return (double)(rk_context->framecount - refframecount) / timediff;
+    else
+        return 0;
+}
+
+static MppCodingType ffrkmpp_get_codingtype(AVCodecContext *avctx)
+{
+    switch(avctx->codec_id) {
+        case AV_CODEC_ID_H264:
+        return MPP_VIDEO_CodingAVC;
+
+        case AV_CODEC_ID_HEVC:
+        return MPP_VIDEO_CodingHEVC;
+
+        case AV_CODEC_ID_VP8:
+        return MPP_VIDEO_CodingVP8;
+
+        default:
+        return MPP_VIDEO_CodingUnused;
+    }
+}
+
+static int ffrkmpp_get_frameformat(MppFrameFormat mppformat)
+{
+    switch(mppformat) {
+        case MPP_FMT_YUV420SP:
+        return DRM_FORMAT_NV12;
+
+        case MPP_FMT_YUV420SP_10BIT:
+        return DRM_FORMAT_NV12_10;
+
+        default:
+        return 0;
+    }
+}
+
+static int ffrkmpp_init_bitstream(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    int ret = 0;
+
+    if (!rk_context->bsf) {
+        const AVBitStreamFilter *bsf;
+
+        // check if we need a bitstream filter
+        switch(avctx->codec_id) {
+            case AV_CODEC_ID_H264:
+            bsf = av_bsf_get_by_name("h264_mp4toannexb");
+            break;
+
+            case AV_CODEC_ID_HEVC:
+            bsf = av_bsf_get_by_name("hevc_mp4toannexb");
+            break;
+
+            default:
+            av_log(avctx, AV_LOG_DEBUG, "Not using any bitstream filter\n");
+            return 0;
+        }
+
+        if(!bsf)
+            return AVERROR_BSF_NOT_FOUND;
+
+        av_log(avctx, AV_LOG_DEBUG, "using bitstream filter %s\n", bsf->name);
+
+        if ((ret = av_bsf_alloc(bsf, &rk_context->bsf)))
+            return ret;
+
+        if (((ret = avcodec_parameters_from_context(rk_context->bsf->par_in, avctx)) < 0) ||
+            ((ret = av_bsf_init(rk_context->bsf)) < 0)) {
+            av_bsf_free(&rk_context->bsf);
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+static int ffrkmpp_write_data(AVCodecContext *avctx, char *buffer, int size, int64_t pts)
+{
+    MppPacket packet;
+    MPP_RET ret = MPP_OK;
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = rk_context->decoder;
+
+    // create the MPP packet
+    ret = mpp_packet_init(&packet, buffer, size);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
+        return ret;
+    }
+
+    // set the pts
+    mpp_packet_set_pts(packet, pts);
+
+    // write it to decoder
+    ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
+
+    if (ret == MPP_ERR_BUFFER_FULL)
+        profile_log(avctx, "Wrote %d bytes to decoder", size);
+
+    mpp_packet_deinit(&packet);
+
+    return ret;
+}
+
+static int ffrkmpp_close_decoder(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = rk_context->decoder;
+
+    ffrk_empty_queue(avctx, &rk_context->framequeue);
+
+    av_buffer_unref(&decoder->ref);
+
+    return 0;
+}
+
+static void ffrkmpp_release_decoder(void *opaque, uint8_t *data)
+{
+    RKMPPDecoder *decoder = (RKMPPDecoder *)data;
+
+    if (decoder) {
+        mpp_destroy(decoder->ctx);
+        decoder->ctx = NULL;
+
+        if (decoder->frame_group) {
+            mpp_buffer_group_put(decoder->frame_group);
+            decoder->frame_group = NULL;
+        }
+
+    }
+
+}
+
+static int ffrkmpp_init_decoder(AVCodecContext *avctx)
+{
+    MPP_RET ret = MPP_OK;
+    MppCodingType codectype = MPP_VIDEO_CodingUnused;
+
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder;
+    int param;
+
+    decoder = av_mallocz(sizeof(RKMPPDecoder));
+    if (!decoder) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    rk_context->decoder = decoder;
+
+    decoder->ref = av_buffer_create((uint8_t*)decoder, sizeof(*decoder), ffrkmpp_release_decoder,
+                                    NULL, AV_BUFFER_FLAG_READONLY);
+    if (!decoder->ref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Initializing RKMPP decoder.\n");
+
+    // Create the MPP context
+    ret = mpp_create(&decoder->ctx, &decoder->mpi);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context (code = %d).\n", ret);
+        goto fail;
+    }
+
+    // initialize the context
+    codectype = ffrkmpp_get_codingtype(avctx);
+    if (codectype == MPP_VIDEO_CodingUnused) {
+        av_log(avctx, AV_LOG_ERROR, "Unknown codec type (%d).\n", ret);
+        goto fail;
+    }
+
+    // initialize mpp
+    ret = mpp_init(decoder->ctx, MPP_CTX_DEC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to initialize MPP context (code = %d).\n", ret);
+        goto fail;
+    }
+
+    // assign a  framegroup to the decoder
+    ret = mpp_buffer_group_get_internal(&decoder->frame_group, MPP_BUFFER_TYPE_ION);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to retrieve a frame group (code = %d).\n", ret);
+        goto fail;
+    }
+
+    ret = decoder->mpi->control(decoder->ctx, MPP_DEC_SET_EXT_BUF_GROUP, decoder->frame_group);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to assign frame group to decoder (code = %d).\n", ret);
+        goto fail;
+    }
+
+    // make decode calls blocking
+    param = MPP_POLL_BLOCK;
+    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK, &param);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set blocking mode on MPI (code = %d).\n", ret);
+        goto fail;
+    }
+
+    param = 100;
+    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK_TIMEOUT, &param);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set block timeout on MPI (code = %d).\n", ret);
+        goto fail;
+    }
+
+    // eventually create a bistream filter for formats that require it
+    ret = ffrkmpp_init_bitstream(avctx);
+    if (ret != 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP bitstream.\n");
+        goto fail;
+    }
+
+    // init our output framequeue
+    ffrk_init_queue(&rk_context->framequeue);
+
+    decoder->first_packet = 1;
+    decoder->eos_reached = 0;
+    rk_context->fill_decoder = 1;
+
+    av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
+        return 0;
+
+fail:
+    if ((decoder) && (decoder->ref))
+        av_buffer_unref(&decoder->ref);
+
+    av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP decoder.\n");
+    ffrkmpp_close_decoder(avctx);
+    return ret;
+}
+
+static int ffrkmpp_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = rk_context->decoder;
+    AVPacket filter_pkt = {0};
+    AVPacket filtered_packet = {0};
+    MPP_RET  ret = MPP_OK;
+    int retcode = 0;
+
+    // handle EOF
+    if (avpkt == NULL) {
+        decoder->eos_reached = 1;
+        return 0;
+    }
+
+    // first we bitstream the packet if it's required
+    // this seems to be required for H264 / HEVC / H265
+    if (rk_context->bsf) {
+        // if we use a bitstream filter, then use it
+        if ((ret = av_packet_ref(&filter_pkt, avpkt)) < 0)
+            return ret;
+
+        if ((ret = av_bsf_send_packet(rk_context->bsf, &filter_pkt)) < 0) {
+            av_packet_unref(&filter_pkt);
+            return ret;
+        }
+
+        if ((ret = av_bsf_receive_packet(rk_context->bsf, &filtered_packet)) < 0)
+            return ret;
+
+        avpkt = &filtered_packet;
+    }
+
+    // on first packet, send extradata
+    if (decoder->first_packet) {
+
+        if (rk_context->bsf)
+            ret = ffrkmpp_write_data(avctx, rk_context->bsf->par_out->extradata,
+                                          rk_context->bsf->par_out->extradata_size,
+                                          avpkt->pts);
+        else
+            ret = ffrkmpp_write_data(avctx, avctx->extradata,
+                                          avctx->extradata_size,
+                                          avpkt->pts);
+        if (ret) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to write extradata to decoder\n");
+            goto fail;
+        }
+
+        decoder->first_packet = 0;
+    }
+
+    // now send packet
+    ret = ffrkmpp_write_data(avctx, avpkt->data, avpkt->size, avpkt->pts);
+    if (ret != MPP_OK) {
+        if (ret == MPP_ERR_BUFFER_FULL) {
+            retcode = AVERROR(EAGAIN);
+            rk_context->fill_decoder = 0;
+        }
+        else {
+            av_log(avctx, AV_LOG_ERROR, "Failed to write data to decoder (%d)\n", ret);
+            goto fail;
+        }
+    }
+
+    // release the ref created by filtered packet
+    if (rk_context->bsf)
+        av_packet_unref(&filtered_packet);
+
+    return retcode;
+
+fail:
+    // release the ref created by filtered packet
+    if (rk_context->bsf)
+        av_packet_unref(&filtered_packet);
+
+    return ret;
+}
+
+
+static void ffrkmpp_release_frame(void *opaque, uint8_t *data)
+{
+    MppFrame mppframe = (MppFrame)opaque;
+
+    pthread_mutex_lock(&release_lock);
+
+    if (mppframe)
+        mpp_frame_deinit(&mppframe);
+
+    pthread_mutex_unlock(&release_lock);
+}
+
+static int ffrkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = rk_context->decoder;
+    MPP_RET  ret = MPP_OK;
+    MppFrame mppframe = NULL;
+    MppBuffer buffer = NULL;
+    MppBufferInfo bufferinfo;
+    av_drmprime *primedata = NULL;
+    double fps;
+
+    // if we want to fill the decoder, switch to send_packet
+    if ((rk_context->fill_decoder) && (!decoder->eos_reached))
+        return AVERROR(EAGAIN);
+
+    // now we will try to get a frame back
+    ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);
+    if ((ret != MPP_OK) && (ret != MPP_ERR_TIMEOUT)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get a frame from MPP (code = %d)\n", ret);
+        goto fail;
+    }
+
+    if (mppframe) {
+        if (mpp_frame_get_info_change(mppframe)) {
+            av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
+                                        mpp_frame_get_width(mppframe),  mpp_frame_get_height(mppframe),
+                                        mpp_frame_get_fmt(mppframe));
+            decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
+            mpp_frame_deinit(&mppframe);
+
+            // here decoder is fully initialized, we need to feed it again with data
+            rk_context->fill_decoder = 1;
+            return AVERROR(EAGAIN);
+        }
+        else {
+            ffrk_queue_frame(avctx, &rk_context->framequeue, mppframe);
+            rk_context->framecount++;
+            fps = ffrkmpp_compute_framerate(avctx);
+            profile_log(avctx, "Received frame, queue size = %d, (%.2f fps)", rk_context->framequeue.size, fps);
+        }
+    }
+
+    // we decode a few frames on decode startup before sending frames
+    // decoder output can be non regular on startup
+    if ((!rk_context->output_started) && (rk_context->framequeue.size < 8))
+        return AVERROR(EAGAIN);
+
+    rk_context->output_started = 1;
+
+    mppframe = ffrk_dequeue_frame(avctx, &rk_context->framequeue);
+
+    if (mppframe) {
+        // setup general frame fields
+        frame->format = AV_PIX_FMT_RKMPP;
+        frame->width  = mpp_frame_get_width(mppframe);
+        frame->height = mpp_frame_get_height(mppframe);
+        frame->pts    = mpp_frame_get_pts(mppframe);
+
+        // now setup the frame buffer info
+        buffer = mpp_frame_get_buffer(mppframe);
+        if (buffer) {
+            ret = mpp_buffer_info_get(buffer, &bufferinfo);
+            if (ret != MPP_OK) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to get info from MPP buffer (code = %d)\n", ret);
+                goto fail;
+            }
+
+            primedata = av_mallocz(sizeof(av_drmprime));
+            if (!primedata) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to allocated drm prime data.\n");
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+
+            // now fill up the DRMPRIME data
+            primedata->strides[0]   = mpp_frame_get_hor_stride(mppframe);
+            primedata->strides[1]   = primedata->strides[0];
+            primedata->offsets[0]   = 0;
+            primedata->offsets[1]   = primedata->strides[0] * mpp_frame_get_ver_stride(mppframe);
+            primedata->fd           = mpp_buffer_get_fd(buffer);
+            primedata->format       = ffrkmpp_get_frameformat(mpp_frame_get_fmt(mppframe));
+
+            frame->data[3] = (uint8_t*)primedata;
+            frame->buf[0]  = av_buffer_create((uint8_t*)primedata, sizeof(*primedata), ffrkmpp_release_frame,
+                                          mppframe, AV_BUFFER_FLAG_READONLY);
+
+            if (!frame->buf[0]) {
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+
+            // add a ref to decoder for each frame
+            frame->buf[1] = av_buffer_ref(decoder->ref);
+
+            return 0;
+        }
+
+    }
+    else {
+        if (decoder->eos_reached)
+            return AVERROR_EOF;
+    }
+
+    return AVERROR(EAGAIN);
+
+fail:
+    if (primedata)
+        av_free(primedata);
+
+    if (mppframe)
+        mpp_frame_deinit(&mppframe);
+
+    return ret;
+}
+
+static void ffrkmpp_flush(AVCodecContext *avctx)
+{
+    MPP_RET ret = MPP_OK;
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = rk_context->decoder;
+
+    ffrk_empty_queue(avctx, &rk_context->framequeue);
+
+    ret = decoder->mpi->reset(decoder->ctx);
+    if (ret == MPP_OK)
+        decoder->first_packet = 1;
+    else
+        av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
+}
+
+#define FFRKMPP_DEC_HWACCEL(NAME, ID) \
+  AVHWAccel ff_##NAME##_rkmpp_hwaccel = { \
+      .name       = #NAME "_rkmpp", \
+      .type       = AVMEDIA_TYPE_VIDEO,\
+      .id         = ID, \
+      .pix_fmt    = AV_PIX_FMT_RKMPP,\
+  };
+
+#define FFRKMPP_DEC_CLASS(NAME) \
+    static const AVClass ffrkmpp_##NAME##_dec_class = { \
+        .class_name = "rkmpp_" #NAME "_dec", \
+        .version    = LIBAVUTIL_VERSION_INT, \
+    };
+
+#define FFRKMPP_DEC(NAME, ID) \
+    FFRKMPP_DEC_CLASS(NAME) \
+    FFRKMPP_DEC_HWACCEL(NAME, ID) \
+    AVCodec ff_##NAME##_rkmpp_decoder = { \
+        .name           = #NAME "_rkmpp", \
+        .long_name      = NULL_IF_CONFIG_SMALL(#NAME " (rkmpp)"), \
+        .type           = AVMEDIA_TYPE_VIDEO, \
+        .id             = ID, \
+        .priv_data_size = sizeof(RKMPPDecodeContext), \
+        .init           = ffrkmpp_init_decoder, \
+        .close          = ffrkmpp_close_decoder, \
+        .send_packet    = ffrkmpp_send_packet, \
+        .receive_frame  = ffrkmpp_receive_frame, \
+        .flush          = ffrkmpp_flush, \
+        .priv_class     = &ffrkmpp_##NAME##_dec_class, \
+        .capabilities   = AV_CODEC_CAP_DELAY, \
+        .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS, \
+        .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_RKMPP, \
+                                                         AV_PIX_FMT_NONE}, \
+    };
+
+FFRKMPP_DEC(h264, AV_CODEC_ID_H264)
+FFRKMPP_DEC(hevc, AV_CODEC_ID_HEVC)
+FFRKMPP_DEC(vp8,  AV_CODEC_ID_VP8)
diff --git a/libavcodec/rkqueue.c b/libavcodec/rkqueue.c
new file mode 100644
index 0000000000..72fdf85669
--- /dev/null
+++ b/libavcodec/rkqueue.c
@@ -0,0 +1,75 @@
+#include "rkqueue.h"
+
+void ffrk_init_queue(FrameQueue *queue)
+{
+    queue->head = NULL;
+    queue->tail = NULL;
+    queue->size = 0;
+}
+
+int ffrk_queue_frame(AVCodecContext *avctx, FrameQueue *queue, MppFrame frame)
+{
+    int ret = 0;
+
+    // create our packet entry for the queue
+    FrameEntry *frameentry = malloc(sizeof(*frameentry));
+    if (!frameentry) {
+        ret = AVERROR(ENOMEM);
+        goto done;
+    }
+
+    frameentry->frame = frame;
+    frameentry->next = NULL;
+    frameentry->prev = NULL;
+
+    // add the packet to start of the queue
+    if (queue->head) {
+        frameentry->next = queue->head;
+        queue->head->prev = frameentry;
+    }
+    
+    if (!queue->tail)
+        queue->tail = frameentry;
+
+    queue->head = frameentry;
+    queue->size++;
+
+    return 0;
+
+done:
+    return ret;
+}
+
+MppFrame ffrk_dequeue_frame(AVCodecContext *avctx, FrameQueue *queue)
+{
+    FrameEntry *frameentry;
+    MppFrame *frame;
+
+    if (!queue->tail)
+        return NULL;
+
+    frameentry = queue->tail;
+    queue->tail = frameentry->prev;
+    
+    if (!queue->tail)
+        queue->head = NULL;
+
+    if (queue->tail)
+        queue->tail->next = NULL;
+
+    queue->size--;
+
+    frame = frameentry->frame;
+    free(frameentry);
+
+    return frame;
+}
+
+void ffrk_empty_queue(AVCodecContext *avctx, FrameQueue *queue)
+{
+    MppFrame frame;
+
+    while(frame = ffrk_dequeue_frame(avctx, queue)) {
+	mpp_frame_deinit(&frame);
+    }
+}
diff --git a/libavcodec/rkqueue.h b/libavcodec/rkqueue.h
new file mode 100644
index 0000000000..d7689f4f3f
--- /dev/null
+++ b/libavcodec/rkqueue.h
@@ -0,0 +1,27 @@
+#ifndef _RKQUEUE_H_
+#define _RKQUEUE_H_
+
+#include <rockchip/mpp_frame.h>
+
+#include "avcodec.h"
+
+// types declaration
+typedef struct FrameEntry {
+  MppFrame frame;
+  struct FrameEntry *next;
+  struct FrameEntry *prev;
+} FrameEntry;
+
+typedef struct FrameQueue {
+  FrameEntry *head;
+  FrameEntry *tail;
+  int size;
+} FrameQueue;
+
+// fucntions prototypes
+void ffrk_init_queue(FrameQueue *queue);
+int ffrk_queue_frame(AVCodecContext *avctx, FrameQueue *queue, MppFrame frame);
+MppFrame ffrk_dequeue_frame(AVCodecContext *avctx, FrameQueue *queue);
+void ffrk_empty_queue(AVCodecContext *avctx, FrameQueue *queue);
+
+#endif /* _RKQUEUE_H_ */
diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
new file mode 100644
index 0000000000..7ef0ac067e
--- /dev/null
+++ b/libavutil/hwcontext_rkmpp.c
@@ -0,0 +1,164 @@
+/*
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "buffer.h"
+#include "common.h"
+#include "hwcontext.h"
+#include "hwcontext_internal.h"
+#include "mem.h"
+#include "pixdesc.h"
+#include "pixfmt.h"
+
+typedef struct RKMPPFramesContext {
+    int dummy;
+} RKMPPFramesContext;
+
+static const enum AVPixelFormat supported_formats[] = {
+    AV_PIX_FMT_NV12,
+};
+
+static int rkmpp_frames_init(AVHWFramesContext *ctx)
+{
+    printf("rkmpp_frames_init called\n");
+    // CUDAFramesContext *priv = ctx->internal->priv;
+    // int i;
+
+    // for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
+        // if (ctx->sw_format == supported_formats[i])
+            // break;
+    // }
+    // if (i == FF_ARRAY_ELEMS(supported_formats)) {
+        // av_log(ctx, AV_LOG_ERROR, "Pixel format '%s' is not supported\n",
+               // av_get_pix_fmt_name(ctx->sw_format));
+        // return AVERROR(ENOSYS);
+    // }
+
+    // av_pix_fmt_get_chroma_sub_sample(ctx->sw_format, &priv->shift_width, &priv->shift_height);
+
+    // if (!ctx->pool) {
+        // int size;
+
+        // switch (ctx->sw_format) {
+        // case AV_PIX_FMT_NV12:
+        // case AV_PIX_FMT_YUV420P:
+            // size = ctx->width * ctx->height * 3 / 2;
+            // break;
+        // case AV_PIX_FMT_YUV444P:
+            // size = ctx->width * ctx->height * 3;
+            // break;
+        // }
+
+        // ctx->internal->pool_internal = av_buffer_pool_init2(size, ctx, cuda_pool_alloc, NULL);
+        // if (!ctx->internal->pool_internal)
+            // return AVERROR(ENOMEM);
+    // }
+
+    return 0;
+}
+
+static int rkmpp_get_buffer(AVHWFramesContext *ctx, AVFrame *frame)
+{
+    printf("rkmpp_get_buffer called\n");
+    // frame->buf[0] = av_buffer_pool_get(ctx->pool);
+    // if (!frame->buf[0])
+        // return AVERROR(ENOMEM);
+
+    // switch (ctx->sw_format) {
+    // case AV_PIX_FMT_NV12:
+        // frame->data[0]     = frame->buf[0]->data;
+        // frame->data[1]     = frame->data[0] + ctx->width * ctx->height;
+        // frame->linesize[0] = ctx->width;
+        // frame->linesize[1] = ctx->width;
+        // break;
+    // case AV_PIX_FMT_YUV420P:
+        // frame->data[0]     = frame->buf[0]->data;
+        // frame->data[2]     = frame->data[0] + ctx->width * ctx->height;
+        // frame->data[1]     = frame->data[2] + ctx->width * ctx->height / 4;
+        // frame->linesize[0] = ctx->width;
+        // frame->linesize[1] = ctx->width / 2;
+        // frame->linesize[2] = ctx->width / 2;
+        // break;
+    // case AV_PIX_FMT_YUV444P:
+        // frame->data[0]     = frame->buf[0]->data;
+        // frame->data[1]     = frame->data[0] + ctx->width * ctx->height;
+        // frame->data[2]     = frame->data[1] + ctx->width * ctx->height;
+        // frame->linesize[0] = ctx->width;
+        // frame->linesize[1] = ctx->width;
+        // frame->linesize[2] = ctx->width;
+        // break;
+    // default:
+        // av_frame_unref(frame);
+        // return AVERROR_BUG;
+    // }
+
+    // frame->format = AV_PIX_FMT_CUDA;
+    // frame->width  = ctx->width;
+    // frame->height = ctx->height;
+
+    return 0;
+}
+
+static int rkmpp_transfer_get_formats(AVHWFramesContext *ctx,
+                                     enum AVHWFrameTransferDirection dir,
+                                     enum AVPixelFormat **formats)
+{
+    enum AVPixelFormat *fmts;
+
+    printf("rkmpp_transfer_get_formats called\n");
+
+    fmts = av_malloc_array(2, sizeof(*fmts));
+    if (!fmts)
+        return AVERROR(ENOMEM);
+
+    fmts[0] = AV_PIX_FMT_NV12;
+    fmts[1] = AV_PIX_FMT_NONE;
+
+    *formats = fmts;
+
+    return 0;
+}
+
+static int rkmpp_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
+                                   const AVFrame *src)
+{
+    printf("rkmpp_transfer_data_from called\n");
+    return 0;
+}
+
+static int rkmpp_transfer_data_to(AVHWFramesContext *ctx, AVFrame *dst,
+                                 const AVFrame *src)
+{
+    printf("rkmpp_transfer_data_to called\n");
+    return 0;
+}
+
+const HWContextType ff_hwcontext_type_rkmpp = {
+    .type                 = AV_HWDEVICE_TYPE_RKMPP,
+    .name                 = "RKMPP",
+
+    //.device_hwctx_size    = sizeof(AVCUDADeviceContext),
+    .frames_priv_size     = sizeof(RKMPPFramesContext),
+
+    .frames_init          = rkmpp_frames_init,
+    .frames_get_buffer    = rkmpp_get_buffer,
+    .transfer_get_formats = rkmpp_transfer_get_formats,
+    .transfer_data_to     = rkmpp_transfer_data_to,
+    .transfer_data_from   = rkmpp_transfer_data_from,
+
+    .pix_fmts             = (const enum AVPixelFormat[]){ AV_PIX_FMT_RKMPP, AV_PIX_FMT_NONE },
+};
diff --git a/libavutil/hwcontext_rkmpp.h b/libavutil/hwcontext_rkmpp.h
new file mode 100644
index 0000000000..069a7541dd
--- /dev/null
+++ b/libavutil/hwcontext_rkmpp.h
@@ -0,0 +1,4 @@
+#ifndef AVUTIL_HWCONTEXT_RKMPP_H
+#define AVUTIL_HWCONTEXT_RKMPP_H
+
+#endif /* AVUTIL_HWCONTEXT_RKMPP_H */
diff --git a/libavutil/pixdesc.c b/libavutil/pixdesc.c
index 0dffa4dbdb..b69eb1d065 100644
--- a/libavutil/pixdesc.c
+++ b/libavutil/pixdesc.c
@@ -1978,6 +1978,10 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         .name = "mmal",
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
+    [AV_PIX_FMT_RKMPP] = {
+            .name = "rkmpp",
+            .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
     [AV_PIX_FMT_CUDA] = {
         .name = "cuda",
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
diff --git a/libavutil/pixfmt.h b/libavutil/pixfmt.h
index 0ed01c4844..bca166f215 100644
--- a/libavutil/pixfmt.h
+++ b/libavutil/pixfmt.h
@@ -247,6 +247,11 @@ enum AVPixelFormat {
      */
     AV_PIX_FMT_CUDA,
 
+      /**
+     * HW acceleration though RockChip Media Process Platform
+     */
+    AV_PIX_FMT_RKMPP,
+
     AV_PIX_FMT_0RGB=0x123+4,///< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined
     AV_PIX_FMT_RGB0,        ///< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined
     AV_PIX_FMT_0BGR,        ///< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined
-- 
2.11.0

